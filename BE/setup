#!/bin/bash

#                                                          .;;,
#                                     .,.               .,;;;;;,
#                                    ;;;;;;;,,        ,;;%%%%%;;
#                                     `;;;%%%%;;,.  ,;;%%;;%%%;;
#                                       `;%%;;%%%;;,;;%%%%%%%;;'
#                                         `;;%%;;%:,;%%%%%;;%%;;,
#                                            `;;%%%,;%%%%%%%%%;;;
#                                               `;:%%%%%%;;%%;;;'
#           ..,,,.                                 .:::::::.
#        .;;;;;;;;;;,.                                  s.
#        `;;;;;;;;;;;;;,                               ,SSSs.
#          `:.:.:.:.:.:.:.                            ,SSSSSSs.
#           .;;;;;;;;;;;;;::,                        ,SSSSSSSSS,
#          ;;;;;;;;;;;;;;;;:::%,                    ,SS%;SSSSSSsS
#         ;;;;;;,:,:::::::;::::%%,                  SS%;SSSSSSsSS
#         ;;;;;,::a@@@@@@a::%%%%%%%,.   ...         SS%;SSSSSSSS'
#         `::::::@@@@@@@@@@@a;%%%%%%%%%'  #;        `SS%;SSSSS'
#  .,sSSSSs;%%,::@@@@@@;;' #`@@a;%%%%%'   ,'          `S%;SS'
#sSSSSSSSSSs;%%%,:@@@@a;;   .@@@a;%%sSSSS'           .%%%;SS,
#`SSSSSSSSSSSs;%%%,:@@@a;;;;@@@;%%sSSSS'        ..,,%%%;SSSSSSs.
#  `SSSSSSSSSSSSs;%%,%%%%%%%%%%%SSSS'     ..,,%;sSSS;%;SSSSSSSSs.
#     `SSSSSSSSSSS%;%;sSSSS;""""   ..,,%sSSSS;;SSSS%%%;SSSSSSSSSS.
#         """""" %%;SSSSSS;;%..,,sSSS;%SSSSS;%;%%%;%%%%;SSSSSS;SSS.
#                `;SSSSS;;%%%%%;SSSS;%%;%;%;sSSS;%%%%%%%;SSSSSS;SSS
#                 ;SSS;;%%%%%%%%;%;%sSSSS%;SSS;%%%%%%%%%;SSSSSS;SSS
#                 `S;;%%%%%%%%%%%%%SSSSS;%%%;%%%%%%%%%%%;SSSSSS;SSS
#                  ;SS;%%%%%%%%%%%%;%;%;%%;%%%%%%%%%%%%;SSSSSS;SSS'
#                  SS;%%%%%%%%%%%%%%%%%%%;%%%%%%%%%%%;SSSSSS;SSS'
#                  SS;%%%%%%%%%%%%%%%%%%;%%%%%%%%%%%;SSSSS;SSS'
#                  SS;%%%%%%%%%%%%%;sSSs;%%%%%%%%;SSSSSS;SSSS
#                  `SS;%%%%%%%%%%%%%%;SS;%%%%%%;SSSSSS;SSSS'
#                   `S;%%%%%%%%%%%%%%%;S;%%%%%;SSSS;SSSSS%
#                    `S;%;%%%%%%%%%%%'   `%%%%;SSS;SSSSSS%.
#                  ,S;%%%%%%%%%%;'      `%%%%%;S   `SSSSs%,.
#                  ,%%%%%%%%%%;%;'         `%;%%%;     `SSSs;%%,.
#               ,%%%%%%;;;%;;%;'           .%%;%%%       `SSSSs;%%.
#            ,%%%%%' .%;%;%;'             ,%%;%%%'         `SSSS;%%
#          ,%%%%'   .%%%%'              ,%%%%%'             `SSs%%'
#        ,%%%%'    .%%%'              ,%%%%'                ,%%%'
#      ,%%%%'     .%%%              ,%%%%'                 ,%%%'
#    ,%%%%'      .%%%'            ,%%%%'                  ,%%%'
#  ,%%%%'        %%%%           ,%%%'                    ,%%%%
#  %%%%'       .:::::         ,%%%'                      %%%%'
#.:::::        :::::'       ,%%%'                       ,%%%%
#:::::'                   ,%%%%'                        %%%%%
#                        %%%%%'                         %%%%%
#                      .::::::                        .::::::
#                      ::::::'                        ::::::'

# -------------------------------------
#
# FuseGIS app deployment script
#
# -------------------------------------

####################################################################
####################################################################
####################################################################
# header "Declaring variables"
####################################################################
####################################################################
####################################################################

# set -o errexit
# target="$1"
# rootPath=$($PWD)

var=" ##"
OS=$(uname)
started=$(date +%Y-%m-%d_%H-%M)
start=$SECONDS

header() {
    echo -e ""
    echo -e ""
    echo -e " ####################################################################"
    echo -e " ####################################################################"
    echo -e " ####################################################################"
    echo -e " #################### $1"
    echo -e " ####################################################################"
    echo -e " ####################################################################"
    echo -e " ####################################################################"
    echo -e ""
}

error() {
    echo -e ""
    echo -e ""
    echo -e " XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
    echo -e " XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
    echo -e " XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
    echo -e " XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
    echo -e " XXXXXXXXXXXX   _____   ____    ____     ___    ____    XXXXXXXXXXXXX"
    echo -e " XXXXXXXXXXXX  | ____| |  _ \  |  _ \   / _ \  |  _ \   XXXXXXXXXXXXX"
    echo -e " XXXXXXXXXXXX  |  _|   | |_) | | |_) | | | | | | |_) |  XXXXXXXXXXXXX"
    echo -e " XXXXXXXXXXXX  | |___  |  _ <  |  _ <  | |_| | |  _ <   XXXXXXXXXXXXX"
    echo -e " XXXXXXXXXXXX  |_____| |_| \_\ |_| \_\  \___/  |_| \_\  XXXXXXXXXXXXX"
    echo -e " XXXXXXXXXXXX                                           XXXXXXXXXXXXX"
    echo -e " XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
    echo -e " XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
    echo -e " XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
    echo -e " XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
    echo -e ""

}
varShow() {
    for i in {$1,$2}; do printf "%-30s %s\n" " ## $i" "is: ${!i}"; done
}

divLine() {
    echo -e " ####################################################################"
}

envKeyValueAsIs() {
    grep -w "$1" .env | cut -d '=' -f 2- | tail -n1
}

envKeyValue() {
    grep -w "$1" .env | cut -d '=' -f 2- | tail -n1 | sed -e "s/^'//g" -e "s/'$//g"
}

# NODE_version=$(node -v)
# NPM_version=$(npm -v)

NODE_v() {
    NODE_version=$(node -v)
    export NODE_version

    divLine
    varShow NODE_version
    divLine
}

NPM_v() {
    NPM_version=$(npm -v)
    export NPM_version

    divLine
    varShow NPM_version
    divLine
}

# select-editor
export EDITOR=nano

####################################################################
####################################################################
####################################################################
header "Magic begun at ${started}!"
####################################################################
####################################################################
####################################################################

divLine
varShow OS

software_02="realpath"
software_02_if_present=$(which ${software_02} | grep "/")
if [ -z "$software_02_if_present" ]; then
    echo -e "$var There is no needed software in the system."
    echo -e "$var Installing it: ${software_02}"
    if [ "${OS}" == "Darwin" ]; then
        brew doctor
        brew update
        brew upgrade
        brew install coreutils
        brew cleanup
    fi

    echo -e "$var Done"
fi

rootPath="$(realpath $PWD)"
varShow rootPath

divLine

AreWeInsideTheAppFolder=$(
    ls |
        grep \
            -e "setup" \
            -e "setup__drop_all_foreign_servers_in_db" \
            -e "README.md" |
        grep "README.md"
)

if [ -z "${AreWeInsideTheAppFolder}" ]; then
    error
    echo -e "$var Please cd to the app directory before running the app."

    exit
fi

if [ -f "$HOME/.pgpass" ]; then
    chmod 600 "$HOME/.pgpass"
fi

####################################################################
####################################################################
####################################################################
header "Software check and install"
####################################################################
####################################################################
####################################################################

if [ "${OS}" == "Darwin" ]; then
    software="brew"
    software_if_present=$(which ${software} | grep "/")
    if [ -z "$software_if_present" ]; then

        echo -e "$var There is no needed software in the system."
        echo -e "$var Installing it: ${software}"

        brewUrl="https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh"
        /bin/bash -c "$(curl -fsSL ${brewUrl})"

        echo -e "$var Done"
    fi
fi

software="pwgen"
software_if_present=$(which ${software} | grep "/")
if [ -z "$software_if_present" ]; then
    echo -e "$var There is no needed software in the system."
    echo -e "$var Installing it: ${software}"
    if [ "${OS}" == "Darwin" ]; then
        brew doctor
        brew update
        brew upgrade
        brew install ${software}
        brew cleanup
    fi
    if [ "${OS}" == "Linux" ]; then
        sudo apt --yes --assume-yes -qq install ${software}
    fi
    echo -e "$var Done"
fi

software="jq"
software_if_present=$(which ${software} | grep "/")
if [ -z "$software_if_present" ]; then
    echo -e "$var There is no needed software in the system."
    echo -e "$var Installing it: ${software}"
    if [ "${OS}" == "Darwin" ]; then
        brew doctor
        brew update
        brew upgrade
        brew install ${software}
        brew cleanup
    fi
    if [ "${OS}" == "Linux" ]; then
        sudo apt --yes --assume-yes -qq install ${software}
    fi
    echo -e "$var Done"
fi

echo -e "$var Done"

####################################################################
####################################################################
####################################################################
header "Reading package.json"
####################################################################
####################################################################
####################################################################

jqAimFileToReadFrom="./package.json"
if [ -f "${jqAimFileToReadFrom}" ]; then
    applicationNamePretty=$(
        jq -cr .config.name "${jqAimFileToReadFrom}"
    )
    applicationVersion=$(
        jq -cr .config.version "${jqAimFileToReadFrom}"
    )
    applicationAuthor=$(
        jq -cr .author "${jqAimFileToReadFrom}"
    )
    applicationDescription=$(
        jq -cr .description "${jqAimFileToReadFrom}"
    )

    varShow applicationNamePretty
    varShow applicationVersion
    varShow applicationAuthor
    varShow applicationDescription

    export applicationNamePretty
    export applicationVersion
    export applicationAuthor
    export applicationDescription
fi

####################################################################
####################################################################
####################################################################
header "Software check and install: Psql special"
####################################################################
####################################################################
####################################################################

psqlInstall() {
    # This part may be needed while installing postgresql-client
    # RELEASE=$(lsb_release -cs)
    the_ppa="apt.postgresql.org"

    if [ "${OS}" == "Darwin" ]; then
        brew doctor
        brew update
        brew install libpq
        brew link --force libpq ail
    fi
    if [ "${OS}" == "Linux" ]; then

        sudo apt --yes --assume-yes -qq remove postgresql-client*

        # If PPA not already added then we'll add it.
        if ! grep -q "^deb .*$the_ppa" /etc/apt/sources.list /etc/apt/sources.list.d/*; then
            wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | sudo apt-key add -
            sudo sh -c 'echo "deb http://apt.postgresql.org/pub/repos/apt/ `lsb_release -cs`-pgdg main" >> /etc/apt/sources.list.d/pgdg.list'

            # Also working variant
            # RELEASE=$(lsb_release -cs)
            # echo -e "deb http://apt.postgresql.org/pub/repos/apt/ ${RELEASE}"-pgdg main |
            #     sudo tee /etc/apt/sources.list.d/pgdg.list
            sudo apt-get --yes --assume-yes -qq update
        fi

        # sudo apt-get --yes --assume-yes -qq install postgresql-client-13

        # This way we should get
        # at least postgresql-client version 12 on Ubuntu 16.04
        sudo apt-get --yes --assume-yes -qq install postgresql-client

    fi
}

software="psql"
software_if_present=$(which ${software} | grep "/")
if [ -z "$software_if_present" ]; then
    echo -e "$var There is no needed software in the system."
    echo -e "$var Installing it: ${software}"
    psqlInstall
    echo -e "$var Done"

fi

targetPgMainHost=$(envKeyValue DATABASE_MAIN_HOST)
targetPgMainPort=$(envKeyValue DATABASE_MAIN_PORT)
targetPgMainBase=$(envKeyValue DATABASE_MAIN_BASE)
targetPgMainUser=$(envKeyValue DATABASE_MAIN_USER)
targetPgMainPass=$(envKeyValue DATABASE_MAIN_PASS)

targetPgUserHost=$(envKeyValue DATABASE_USER_HOST)
targetPgUserPort=$(envKeyValue DATABASE_USER_PORT)
targetPgUserBase=$(envKeyValue DATABASE_USER_BASE)
targetPgUserUser=$(envKeyValue DATABASE_USER_USER)
targetPgUserPass=$(envKeyValue DATABASE_USER_PASS)

psqlExecuteFileOnMain() {

    PGPASSWORD="$targetPgMainPass"
    export PGPASSWORD

    psql \
        -qtAX \
        --host="${targetPgMainHost}" \
        --port="${targetPgMainPort}" \
        --dbname="${targetPgMainBase}" \
        --username="${targetPgMainUser}" \
        -v ON_ERROR_STOP=1 \
        --file="$1"
}

psqlExecuteCommandOnMain() {

    PGPASSWORD="$targetPgMainPass"
    export PGPASSWORD

    psql \
        -qtAX \
        --host="${targetPgMainHost}" \
        --port="${targetPgMainPort}" \
        --dbname="${targetPgMainBase}" \
        --username="${targetPgMainUser}" \
        -v ON_ERROR_STOP=1 \
        --command="$1 $2 $3 $4"
}

psqlExecuteCommandOnUser() {

    PGPASSWORD="$targetPgUserPass"
    export PGPASSWORD

    psql \
        -qtAX \
        --host="${targetPgUserHost}" \
        --port="${targetPgUserPort}" \
        --dbname="${targetPgUserBase}" \
        --username="${targetPgUserUser}" \
        -v ON_ERROR_STOP=1 \
        --command="$1 $2 $3 $4"
}

echo -e "$var PostgreSQL software on current machine is:"
psql_local=$(psql --version) || error
echo -e "${psql_local}"

psql_local_integer=$(echo -e "${psql_local}" |
    sed "s/psql//g; s/PostgreSQL//g; s/[()]//g; s/ //g; s/\..*$//g")
echo -e "${psql_local_integer}"

echo -e "$var PostgreSQL software on remote machine is:"
psqlExecuteCommandOnMain "SELECT version();" >.psql_remote.info || error
cat ".psql_remote.info"

psql_remote_integer=$(
    cat ".psql_remote.info" |
        grep PostgreSQL |
        sed "s/^version.*SQL//g; s/on.*$//g; s/PostgreSQL//g; s/\..*$//g; s/ //g"
)
echo -e "${psql_remote_integer}"

# If already installed local psql version is greater or equal to one that is
# on the remote server then everythig is ok and we can process script further.
# If not, then we should delete installed local psql and install
# one that will be equal or greater to one that is on the remote server.
if [[ $psql_local_integer -ge $psql_remote_integer ]]; then
    echo -e "$var :)"
else
    echo -e "$var :("
    psqlInstall
fi

echo -e "$var Done"

####################################################################
####################################################################
####################################################################
header "Software check and install: Node special"
####################################################################
####################################################################
####################################################################

NODE_v
NPM_v

software="node"
software_if_present=$(which ${software} | grep "/")
# software_if_fresh_enough=$(node -v | grep -e v14 -e v15 -e v16)
software_if_fresh_enough=$(node -v | grep -e v16)
if [ -z "$software_if_present" ] ||
    [ -z "$software_if_fresh_enough" ]; then
    echo -e "$var There is no needed software in the system."
    echo -e "$var Installing it: ${software}"
    if [ "${OS}" == "Darwin" ]; then
        brew doctor
        brew update
        brew upgrade
        brew install ${software}
    fi
    if [ "${OS}" == "Linux" ]; then

        sudo apt --yes --assume-yes -qq purge nodejs &&
            sudo apt --yes --assume-yes -qq autoremove --purge
        # curl -sL https://deb.nodesource.com/setup_14.x | sudo -E bash -
        curl -sL https://deb.nodesource.com/setup_16.x | sudo -E bash -

        # To remove the nodesource PPA repository list and update the apt repo.
        # sudo rm /etc/apt/sources.list.d/nodesources.list*

        sudo apt --yes --assume-yes -qq update
        sudo apt --yes --assume-yes -qq upgrade
        sudo apt --yes --assume-yes -qq install nodejs
    fi

    NODE_v
    NPM_v
fi

# software_if_fresh_enough=$(node -v | grep -e v14 -e v15 -e v16)
software_if_fresh_enough=$(node -v | grep -e v16)
if [ -z "$software_if_fresh_enough" ]; then
    error
    echo -e "$var App likes fresh Node software as of version 16"

    exit
fi

npm config set prefix ~/.npm
export PATH=$HOME/.npm/bin:$PATH
export NODE_OPTIONS=--max_old_space_size=4096

if [ "${OS}" == "Darwin" ]; then

    # npm ERR! code ENOTEMPTY
    # npm ERR! syscall rename
    # npm ERR! path /usr/local/lib/node_modules/npm
    # npm ERR! dest /usr/local/lib/node_modules/.npm-i9nnxROI
    # npm ERR! errno -66
    # npm ERR! ENOTEMPTY: directory not empty, rename '/usr/local/lib/node_modules/npm' - >'/usr/local/lib/node_modules/.npm-i9nnxROI'

    if
        [ -z $(
            ls "/usr/local/lib/node_modules/".npm-* | grep "no matches found"
        ) ]
    then
        rm -rf "/usr/local/lib/node_modules/".npm-*
    fi

fi

npm --loglevel=error install -g npm@latest --silent

npm --loglevel=error install -g npm
NPM_v
npm --loglevel=error install -g npm

# if [ "$target" == "PROD" ]; then

software="pm2"
software_if_present=$(which ${software} | grep "/")
if [ -z "$software_if_present" ]; then
    echo -e "$var There is no needed software in the system."
    echo -e "$var Installing it: ${software}"
    npm --loglevel=error install -g pm2@latest --silent
    echo -e "$var Done"
else
    npm --loglevel=error install -g pm2@latest --silent
    echo -e "$var ${software} upgraded"
fi

appRunning=$(pm2 list | grep "${applicationNamePretty}" | grep "online")

if [ -n "$appRunning" ]; then

    ####################################################################
    ####################################################################
    ####################################################################
    header "Stopping app held by PM2"
    ####################################################################
    ####################################################################
    ####################################################################

    # pm2 update
    pm2 set pm2:autodump true
    # pm2 save --force
    pm2 list
    pm2 stop "${applicationNamePretty}"
    pm2 delete "${applicationNamePretty}"
    pm2 save --force
    pm2 list
    echo -e "$var Done"

fi

# fi

echo -e "$var Done"

####################################################################
####################################################################
####################################################################
header "Adding variables to the .env file"
####################################################################
####################################################################
####################################################################

if [ -f "${rootPath}/.env" ]; then
    cat >>"${rootPath}/.env" <<EOL

####################################################################
####################################################################
####################################################################
#################### GENERAL part for all instances [AUTO ADDED]
####################################################################
####################################################################
####################################################################

############################ APPLICATION VERSION, MODE & PORT
############################
APPLICATION_VERSION         ='thePrettiestAppVersion'
APPLICATION_MODE            ='production'
APPLICATION_PORT            ='3000'


############################ LOGIN TOKEN SETTINGS
############################
LOGIN_TOKEN_SECRET          ='ChangeMePleaseToSecureLoginTokenSecret'
LOGIN_TOKEN_SECRET_REFRESH  ='SecureLoginTokenSecretRefresh'
# 14 days  in seconds
LOGIN_TOKEN_LIFE            =1209600
# 14 days  in seconds
LOGIN_TOKEN_LIFE_REFRESH    =1209600


############################ PASSWORD TOKEN SETTINGS
############################
# 24 hours in seconds
# PASSWORD_RESET_TOKEN_LIFE   =86400


############################ EMAIL TOKEN SETTINGS
############################
# 30 minutes in seconds
EMAIL_VALIDATION_TOKEN_LIFE =1800


############################ EXTERNAL ELEVATION (CONTOURS) APP
############################
EXTERNAL_SERVICE_API        ='http://localhost:3001'


############################ EMAIL SETTINGS
############################
EMAIL_FROM                  ='team@fusegis.com'
EMAIL_SUPPORT               ='team@fusegis.com'


############################ AWS S3 -- EMAIL TEMPLATES
############################
AWS_01_REGION               ='us-east-2'
AWS_01_BUCKET_NAME          ='fuseemailtemplates1014'
AWS_01_S3_API_VERSION       ='2006-03-01'
AWS_01_LOGO                 ='https://fuseemailtemplates1014.s3.us-east-2.amazonaws.com/img/logo1+-+color+1.png'


############################ AWS S3 -- FILTER EXPORT
############################
AWS_02_BUCKET_NAME          ='fs10411us'
AWS_02_EXPORTED_FILE_LINK   ='https://fs10411us.s3.amazonaws.com/export/'


############################ DATABASE USERS -- EXTERNAL
############################
USERS_FOREIGN_SCHEMA        ='users__foreign'

EOL

fi

echo -e "$var Done"

####################################################################
####################################################################
####################################################################
header "Generating app login tokens"
####################################################################
####################################################################
####################################################################

if [ -f "${rootPath}/.env" ]; then

    isOkForChange_login_token_secret=$(
        grep <"${rootPath}/.env" -e "ChangeMePleaseToSecureLoginTokenSecret"
    )

    if [ -z "${isOkForChange_login_token_secret}" ]; then
        error
        echo -e "$var No login token == no working app."

        exit
    else

        passwordArray=$(pwgen --secure 8 8)
        LOGIN_TOKEN_SECRET=$(echo -e $passwordArray | sed "s| |-|g")

        # LOGIN_TOKEN_SECRET=${passwordArray// /-}

        if [ "${OS}" == "Darwin" ]; then
            sed -i "" \
                "s|ChangeMePleaseToSecureLoginTokenSecret|${LOGIN_TOKEN_SECRET}|" \
                "${rootPath}/.env"
        fi

        if [ "${OS}" == "Linux" ]; then
            sed -i \
                "s|ChangeMePleaseToSecureLoginTokenSecret|${LOGIN_TOKEN_SECRET}|" \
                "${rootPath}/.env"
        fi

        # sed <"${rootPath}/.env" \
        #     "s|ChangeMePleaseToSecureLoginTokenSecret|${LOGIN_TOKEN_SECRET}|" \
        #     >"${rootPath}/.env_tmp"
        # rm -f "${rootPath}/.env"
        # mv "${rootPath}/.env_tmp" "${rootPath}/.env"

    fi

    isOkForChange_login_token_secret_refresh=$(
        grep <"${rootPath}/.env" -e "SecureLoginTokenSecretRefresh"
    )

    if [ -z "${isOkForChange_login_token_secret_refresh}" ]; then
        error
        echo -e "$var No login refresh token == no working app."
        exit
    else

        passwordArray=$(pwgen --secure 8 8)
        LOGIN_TOKEN_SECRET_REFRESH=$(echo -e $passwordArray | sed "s| |-|g")

        # LOGIN_TOKEN_SECRET_REFRESH=${passwordArray// /-}

        if [ "${OS}" == "Darwin" ]; then
            sed -i "" \
                "s|SecureLoginTokenSecretRefresh|${LOGIN_TOKEN_SECRET_REFRESH}|" \
                "${rootPath}/.env"
        fi

        if [ "${OS}" == "Linux" ]; then
            sed -i \
                "s|SecureLoginTokenSecretRefresh|${LOGIN_TOKEN_SECRET_REFRESH}|" \
                "${rootPath}/.env"
        fi

        # sed <"${rootPath}/.env" \
        #     "s|SecureLoginTokenSecretRefresh|${LOGIN_TOKEN_SECRET_REFRESH}|" \
        #     >"${rootPath}/.env_tmp"
        # rm -f "${rootPath}/.env"
        # mv "${rootPath}/.env_tmp" "${rootPath}/.env"

    fi

else
    error
    echo -e "$var No login tokens == no working app."

    exit
fi

echo -e "$var Done"

####################################################################
####################################################################
####################################################################
header "Checking if token life was entered correctly"
####################################################################
####################################################################
####################################################################

isLoginTokenLifeCorrect=$(
    grep <"${rootPath}/.env" -e "1209600" -e "86400" |
        grep "LOGIN_TOKEN_LIFE_REFRESH"
)

if [ -z "${isLoginTokenLifeCorrect}" ]; then
    error
    echo -e "$var You've entered wrong env key values."

    exit
fi

echo -e "$var Done"

####################################################################
####################################################################
####################################################################
header "Checking env key values formatting/existance"
####################################################################
####################################################################
####################################################################

declare -a processing_array=(
    APPLICATION_APP_LAYER
    APPLICATION_DOMAIN
    APPLICATION_WEB_LAYER
    AWS_01_ACCESS_KEY_ID
    AWS_01_SECRET_ACCESS_KEY
    AWS_02_ACCESS_KEY_ID
    AWS_02_SECRET_ACCESS_KEY
    DATABASE_MAIN_BASE
    DATABASE_MAIN_HOST
    DATABASE_MAIN_PASS
    DATABASE_MAIN_PORT
    DATABASE_MAIN_USER
    DATABASE_USER_BASE
    DATABASE_USER_HOST
    DATABASE_USER_PASS
    DATABASE_USER_PORT
    DATABASE_USER_USER
    FACEBOOK_APP_ID
    FACEBOOK_APP_SECRET
    GOOGLE_CLIENT_ID
    GOOGLE_CLIENT_SECRET
    GOOGLE_REFRESH_TOKEN
    MAPBOX_STYLE_TOKEN
    MAPBOX_TOKEN
    STRIPE_PUBLISH_KEY
    STRIPE_SECRET_KEY
    STRIPE_SUBSCRIPTION_PLAN
    STRIPE_WEBHOOK_SECRET
)

TotalToDo="${#processing_array[@]}"
n=0
for processing in "${processing_array[@]}"; do
    n=$((n + 1))
    # echo -e ""
    echo -e " ##################### Processing ${n}/${TotalToDo} ${processing}"
    # echo -e ""
    ifEnvKeyValueFormatted=$(envKeyValueAsIs ${processing} | grep "'$" | grep "^'")
    if [ -z "${ifEnvKeyValueFormatted}" ]; then
        error
        echo -e "$var Your env key values formatting is wrong."
        exit
    fi
done

echo -e "$var Done"

####################################################################
####################################################################
####################################################################
header "Installing Node modules"
####################################################################
####################################################################
####################################################################

# npm --loglevel=error install --silence
npm --loglevel=error install --silent

# npm audit fix --force

echo -e "$var Done"

####################################################################
####################################################################
####################################################################
header "Outdated Node modules"
####################################################################
####################################################################
####################################################################

if [ -n "$(cat .env | grep "LOCALHOST specific")" ]; then
    ####################################################################
    # header "NO outdated Node modules on LOCALHOST"
    ####################################################################
    npm --loglevel=error install --save-dev ncu --silent
    ncu -u
    npm --loglevel=error install --silent
else
    ####################################################################
    # header "Let them be on PROD"
    ####################################################################
    # Variant 1
    npm outdated --depth=3

    # Variant 2
    # npm --loglevel=error install npm-check --save-dev
    # npx npm-check
fi

echo -e "$var Done"

####################################################################
####################################################################
####################################################################
header "Connecting external DB for users only"
####################################################################
####################################################################
####################################################################

usersForeignSchema=$(envKeyValue USERS_FOREIGN_SCHEMA)
userSqlServerToBeConnected="foreign_server__localhost_5432"

####################################################################
# for the DEBUG only:
# To check if all used variables for the foreign schema connection are valid

# varShow userSqlServerToBeConnected
# varShow usersForeignSchema
# varShow targetPgMainUser
# varShow targetPgUserHost
# varShow targetPgUserPort
# varShow targetPgUserBase
# varShow targetPgUserUser
# varShow targetPgUserPass
####################################################################

echo -e "$var Creating extension"
psqlExecuteCommandOnMain "
            CREATE EXTENSION
                IF NOT EXISTS postgres_fdw;
            "

echo -e "$var Dropping everything related"
psqlExecuteFileOnMain "./setup__drop_all_foreign_servers_in_db"

# psqlExecuteCommandOnMain "
#             DROP SCHEMA
#                 IF EXISTS ${usersForeignSchema} CASCADE;

#             DROP USER MAPPING
#                 IF EXISTS
#                     FOR ${targetPgMainUser}
#                     SERVER ${userSqlServerToBeConnected};

#             DROP SERVER
#                 IF EXISTS ${userSqlServerToBeConnected};
#             "

echo -e "$var Creating server"
psqlExecuteCommandOnMain "
            CREATE SERVER
                IF NOT EXISTS ${userSqlServerToBeConnected}
                FOREIGN DATA WRAPPER postgres_fdw
                OPTIONS
                    (
                        host '${targetPgUserHost}',
                        port '${targetPgUserPort}',
                        dbname '${targetPgUserBase}'
                    );
            "

echo -e "$var Creating user"
psqlExecuteCommandOnMain "
            CREATE USER MAPPING
                IF NOT EXISTS FOR ${targetPgMainUser}
                SERVER ${userSqlServerToBeConnected}
                OPTIONS
                    (
                        user '${targetPgUserUser}',
                        password '${targetPgUserPass}'
                    );
            "

echo -e "$var Creating schema"
psqlExecuteCommandOnMain "
            CREATE SCHEMA
                IF NOT EXISTS ${usersForeignSchema};
            "

echo -e "$var Importing foreign schema"
psqlExecuteCommandOnMain "
            IMPORT FOREIGN SCHEMA users
                FROM SERVER ${userSqlServerToBeConnected}
                INTO ${usersForeignSchema};
            "

echo -e "$var Done"

####################################################################
####################################################################
####################################################################
header "Logging out each and every user"
####################################################################
####################################################################
####################################################################

psqlExecuteCommandOnUser "
            UPDATE users.users SET
                should_cache_be_cleared = TRUE
                WHERE TRUE;
                "
echo -e "$var Done"

####################################################################
####################################################################
####################################################################
header "Generating url for mail sendings"
####################################################################
####################################################################
####################################################################

stringToMd5() {
    printf '%s' "$1" | md5sum | awk '{print $1}'
}

loginTokenSecret=$(envKeyValue LOGIN_TOKEN_SECRET)
loginTokenSecretInMd5=$(stringToMd5 "${loginTokenSecret}")

varShow loginTokenSecret
varShow loginTokenSecretInMd5

applicationDomain=$(envKeyValue APPLICATION_DOMAIN)
applicationAppLayer=$(envKeyValue APPLICATION_APP_LAYER)
applicationPort=$(envKeyValue APPLICATION_PORT)

varShow applicationDomain
varShow applicationAppLayer
varShow applicationPort

magicUrlToSendMail="http://${applicationAppLayer}.${applicationDomain}:${applicationPort}/mailing-${loginTokenSecretInMd5}"

varShow magicUrlToSendMail

# ifJobAlreadyAdded=$(crontab -l | grep "0 4 * * * curl http://")
# crontab -l | sed '/curl http/d' | crontab -

# We can also list all users in the system this ways:
# less /etc/passwd
# getent passwd
# compgen -u
# cut -d: -f1 /etc/passwd
# getent passwd | awk -F: '{ print $1}'

userToGetTheJobDone="ubuntu"
crontabFile="/var/spool/cron/crontabs/${userToGetTheJobDone}"

ifUserExists=$(compgen -u | grep "$userToGetTheJobDone")

if [ -n "${ifUserExists}" ] && [ "${rootPath}" == "/home/ubuntu/app" ]; then

    # crontab -u ${userToGetTheJobDone} -e
    sudo touch ${crontabFile}
    sudo chown ${userToGetTheJobDone}:${userToGetTheJobDone} ${crontabFile}

    # Deleting job from cron
    crontab -l -u "$userToGetTheJobDone" |
        sed '/curl http/d' |
        crontab -u "$userToGetTheJobDone" -

    # Adding job to cron
    (
        crontab -l 2>/dev/null || true
        echo -e "0 4 * * * curl ${magicUrlToSendMail}"
    ) |
        crontab -

fi

echo -e "$var Done"

####################################################################
####################################################################
####################################################################
header "Reading application version from the package.json file"
####################################################################
####################################################################
####################################################################

if [ -f "${rootPath}/.env" ]; then

    isOkForChange_ApplicationVersion=$(
        grep <"${rootPath}/.env" -e "thePrettiestAppVersion"
    )

    if [ -z "${isOkForChange_ApplicationVersion}" ]; then
        error
        echo -e "$var No Application Version == no working app :)"

        exit
    else

        APPLICATION_VERSION=$(npm run env | grep npm_package_config_version | cut -d '=' -f 2)

        sed <"${rootPath}/.env" \
            "s|thePrettiestAppVersion|${APPLICATION_VERSION}|" \
            >"${rootPath}/.env_tmp"
        rm -f "${rootPath}/.env"
        mv "${rootPath}/.env_tmp" "${rootPath}/.env"

    fi

else
    error
    echo -e "$var No Application Version == no working app :)"

    exit
fi

echo -e "$var Done"

####################################################################
####################################################################
####################################################################
header "All went good"
####################################################################
####################################################################
####################################################################

duration=$((SECONDS - start))
DurationInMinutes=$((duration / 60))
ended=$(date +%Y-%m-%d....%H-%M)

echo -e "$var Magic report:"
echo -e "$var Started at $started"
echo -e "$var Ended at   $ended"
echo -e "$var Processed in about $DurationInMinutes minutes."
